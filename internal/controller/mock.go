package controller

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i Avito/internal/controller.IRepository -o ./i_repository_mock_test.go -n IRepositoryMock

import (
	"Avito/internal/model"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// IRepositoryMock implements IRepository
type IRepositoryMock struct {
	t minimock.Tester

	funcAddUser          func(user model.User) (err error)
	inspectFuncAddUser   func(user model.User)
	afterAddUserCounter  uint64
	beforeAddUserCounter uint64
	AddUserMock          mIRepositoryMockAddUser

	funcBalance          func(userID uuid.UUID) (up1 *model.User, err error)
	inspectFuncBalance   func(userID uuid.UUID)
	afterBalanceCounter  uint64
	beforeBalanceCounter uint64
	BalanceMock          mIRepositoryMockBalance

	funcEnrollment          func(user model.User, funds float64) (err error)
	inspectFuncEnrollment   func(user model.User, funds float64)
	afterEnrollmentCounter  uint64
	beforeEnrollmentCounter uint64
	EnrollmentMock          mIRepositoryMockEnrollment

	funcGetOrder          func(orderID uuid.UUID) (op1 *model.Order, err error)
	inspectFuncGetOrder   func(orderID uuid.UUID)
	afterGetOrderCounter  uint64
	beforeGetOrderCounter uint64
	GetOrderMock          mIRepositoryMockGetOrder

	funcHistory          func(userID uuid.UUID, limit int, offset int) (ha1 []model.History, err error)
	inspectFuncHistory   func(userID uuid.UUID, limit int, offset int)
	afterHistoryCounter  uint64
	beforeHistoryCounter uint64
	HistoryMock          mIRepositoryMockHistory

	funcOrder          func(user model.User, order model.Order) (err error)
	inspectFuncOrder   func(user model.User, order model.Order)
	afterOrderCounter  uint64
	beforeOrderCounter uint64
	OrderMock          mIRepositoryMockOrder

	funcOrderFailed          func(user model.User, order model.Order) (err error)
	inspectFuncOrderFailed   func(user model.User, order model.Order)
	afterOrderFailedCounter  uint64
	beforeOrderFailedCounter uint64
	OrderFailedMock          mIRepositoryMockOrderFailed

	funcOrderSuccess          func(order model.Order) (err error)
	inspectFuncOrderSuccess   func(order model.Order)
	afterOrderSuccessCounter  uint64
	beforeOrderSuccessCounter uint64
	OrderSuccessMock          mIRepositoryMockOrderSuccess

	funcReport          func(t1 time.Time) (ra1 []model.Report, err error)
	inspectFuncReport   func(t1 time.Time)
	afterReportCounter  uint64
	beforeReportCounter uint64
	ReportMock          mIRepositoryMockReport

	funcTransfer          func(sender model.User, recipient model.User, funds float64) (err error)
	inspectFuncTransfer   func(sender model.User, recipient model.User, funds float64)
	afterTransferCounter  uint64
	beforeTransferCounter uint64
	TransferMock          mIRepositoryMockTransfer
}

// NewIRepositoryMock returns a mock for IRepository
func NewIRepositoryMock(t minimock.Tester) *IRepositoryMock {
	m := &IRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddUserMock = mIRepositoryMockAddUser{mock: m}
	m.AddUserMock.callArgs = []*IRepositoryMockAddUserParams{}

	m.BalanceMock = mIRepositoryMockBalance{mock: m}
	m.BalanceMock.callArgs = []*IRepositoryMockBalanceParams{}

	m.EnrollmentMock = mIRepositoryMockEnrollment{mock: m}
	m.EnrollmentMock.callArgs = []*IRepositoryMockEnrollmentParams{}

	m.GetOrderMock = mIRepositoryMockGetOrder{mock: m}
	m.GetOrderMock.callArgs = []*IRepositoryMockGetOrderParams{}

	m.HistoryMock = mIRepositoryMockHistory{mock: m}
	m.HistoryMock.callArgs = []*IRepositoryMockHistoryParams{}

	m.OrderMock = mIRepositoryMockOrder{mock: m}
	m.OrderMock.callArgs = []*IRepositoryMockOrderParams{}

	m.OrderFailedMock = mIRepositoryMockOrderFailed{mock: m}
	m.OrderFailedMock.callArgs = []*IRepositoryMockOrderFailedParams{}

	m.OrderSuccessMock = mIRepositoryMockOrderSuccess{mock: m}
	m.OrderSuccessMock.callArgs = []*IRepositoryMockOrderSuccessParams{}

	m.ReportMock = mIRepositoryMockReport{mock: m}
	m.ReportMock.callArgs = []*IRepositoryMockReportParams{}

	m.TransferMock = mIRepositoryMockTransfer{mock: m}
	m.TransferMock.callArgs = []*IRepositoryMockTransferParams{}

	return m
}

type mIRepositoryMockAddUser struct {
	mock               *IRepositoryMock
	defaultExpectation *IRepositoryMockAddUserExpectation
	expectations       []*IRepositoryMockAddUserExpectation

	callArgs []*IRepositoryMockAddUserParams
	mutex    sync.RWMutex
}

// IRepositoryMockAddUserExpectation specifies expectation struct of the IRepository.AddUser
type IRepositoryMockAddUserExpectation struct {
	mock    *IRepositoryMock
	params  *IRepositoryMockAddUserParams
	results *IRepositoryMockAddUserResults
	Counter uint64
}

// IRepositoryMockAddUserParams contains parameters of the IRepository.AddUser
type IRepositoryMockAddUserParams struct {
	user model.User
}

// IRepositoryMockAddUserResults contains results of the IRepository.AddUser
type IRepositoryMockAddUserResults struct {
	err error
}

// Expect sets up expected params for IRepository.AddUser
func (mmAddUser *mIRepositoryMockAddUser) Expect(user model.User) *mIRepositoryMockAddUser {
	if mmAddUser.mock.funcAddUser != nil {
		mmAddUser.mock.t.Fatalf("IRepositoryMock.AddUser mock is already set by Set")
	}

	if mmAddUser.defaultExpectation == nil {
		mmAddUser.defaultExpectation = &IRepositoryMockAddUserExpectation{}
	}

	mmAddUser.defaultExpectation.params = &IRepositoryMockAddUserParams{user}
	for _, e := range mmAddUser.expectations {
		if minimock.Equal(e.params, mmAddUser.defaultExpectation.params) {
			mmAddUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddUser.defaultExpectation.params)
		}
	}

	return mmAddUser
}

// Inspect accepts an inspector function that has same arguments as the IRepository.AddUser
func (mmAddUser *mIRepositoryMockAddUser) Inspect(f func(user model.User)) *mIRepositoryMockAddUser {
	if mmAddUser.mock.inspectFuncAddUser != nil {
		mmAddUser.mock.t.Fatalf("Inspect function is already set for IRepositoryMock.AddUser")
	}

	mmAddUser.mock.inspectFuncAddUser = f

	return mmAddUser
}

// Return sets up results that will be returned by IRepository.AddUser
func (mmAddUser *mIRepositoryMockAddUser) Return(err error) *IRepositoryMock {
	if mmAddUser.mock.funcAddUser != nil {
		mmAddUser.mock.t.Fatalf("IRepositoryMock.AddUser mock is already set by Set")
	}

	if mmAddUser.defaultExpectation == nil {
		mmAddUser.defaultExpectation = &IRepositoryMockAddUserExpectation{mock: mmAddUser.mock}
	}
	mmAddUser.defaultExpectation.results = &IRepositoryMockAddUserResults{err}
	return mmAddUser.mock
}

//Set uses given function f to mock the IRepository.AddUser method
func (mmAddUser *mIRepositoryMockAddUser) Set(f func(user model.User) (err error)) *IRepositoryMock {
	if mmAddUser.defaultExpectation != nil {
		mmAddUser.mock.t.Fatalf("Default expectation is already set for the IRepository.AddUser method")
	}

	if len(mmAddUser.expectations) > 0 {
		mmAddUser.mock.t.Fatalf("Some expectations are already set for the IRepository.AddUser method")
	}

	mmAddUser.mock.funcAddUser = f
	return mmAddUser.mock
}

// When sets expectation for the IRepository.AddUser which will trigger the result defined by the following
// Then helper
func (mmAddUser *mIRepositoryMockAddUser) When(user model.User) *IRepositoryMockAddUserExpectation {
	if mmAddUser.mock.funcAddUser != nil {
		mmAddUser.mock.t.Fatalf("IRepositoryMock.AddUser mock is already set by Set")
	}

	expectation := &IRepositoryMockAddUserExpectation{
		mock:   mmAddUser.mock,
		params: &IRepositoryMockAddUserParams{user},
	}
	mmAddUser.expectations = append(mmAddUser.expectations, expectation)
	return expectation
}

// Then sets up IRepository.AddUser return parameters for the expectation previously defined by the When method
func (e *IRepositoryMockAddUserExpectation) Then(err error) *IRepositoryMock {
	e.results = &IRepositoryMockAddUserResults{err}
	return e.mock
}

// AddUser implements IRepository
func (mmAddUser *IRepositoryMock) AddUser(user model.User) (err error) {
	mm_atomic.AddUint64(&mmAddUser.beforeAddUserCounter, 1)
	defer mm_atomic.AddUint64(&mmAddUser.afterAddUserCounter, 1)

	if mmAddUser.inspectFuncAddUser != nil {
		mmAddUser.inspectFuncAddUser(user)
	}

	mm_params := &IRepositoryMockAddUserParams{user}

	// Record call args
	mmAddUser.AddUserMock.mutex.Lock()
	mmAddUser.AddUserMock.callArgs = append(mmAddUser.AddUserMock.callArgs, mm_params)
	mmAddUser.AddUserMock.mutex.Unlock()

	for _, e := range mmAddUser.AddUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddUser.AddUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddUser.AddUserMock.defaultExpectation.Counter, 1)
		mm_want := mmAddUser.AddUserMock.defaultExpectation.params
		mm_got := IRepositoryMockAddUserParams{user}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddUser.t.Errorf("IRepositoryMock.AddUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddUser.AddUserMock.defaultExpectation.results
		if mm_results == nil {
			mmAddUser.t.Fatal("No results are set for the IRepositoryMock.AddUser")
		}
		return (*mm_results).err
	}
	if mmAddUser.funcAddUser != nil {
		return mmAddUser.funcAddUser(user)
	}
	mmAddUser.t.Fatalf("Unexpected call to IRepositoryMock.AddUser. %v", user)
	return
}

// AddUserAfterCounter returns a count of finished IRepositoryMock.AddUser invocations
func (mmAddUser *IRepositoryMock) AddUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddUser.afterAddUserCounter)
}

// AddUserBeforeCounter returns a count of IRepositoryMock.AddUser invocations
func (mmAddUser *IRepositoryMock) AddUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddUser.beforeAddUserCounter)
}

// Calls returns a list of arguments used in each call to IRepositoryMock.AddUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddUser *mIRepositoryMockAddUser) Calls() []*IRepositoryMockAddUserParams {
	mmAddUser.mutex.RLock()

	argCopy := make([]*IRepositoryMockAddUserParams, len(mmAddUser.callArgs))
	copy(argCopy, mmAddUser.callArgs)

	mmAddUser.mutex.RUnlock()

	return argCopy
}

// MinimockAddUserDone returns true if the count of the AddUser invocations corresponds
// the number of defined expectations
func (m *IRepositoryMock) MinimockAddUserDone() bool {
	for _, e := range m.AddUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddUser != nil && mm_atomic.LoadUint64(&m.afterAddUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddUserInspect logs each unmet expectation
func (m *IRepositoryMock) MinimockAddUserInspect() {
	for _, e := range m.AddUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IRepositoryMock.AddUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddUserCounter) < 1 {
		if m.AddUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IRepositoryMock.AddUser")
		} else {
			m.t.Errorf("Expected call to IRepositoryMock.AddUser with params: %#v", *m.AddUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddUser != nil && mm_atomic.LoadUint64(&m.afterAddUserCounter) < 1 {
		m.t.Error("Expected call to IRepositoryMock.AddUser")
	}
}

type mIRepositoryMockBalance struct {
	mock               *IRepositoryMock
	defaultExpectation *IRepositoryMockBalanceExpectation
	expectations       []*IRepositoryMockBalanceExpectation

	callArgs []*IRepositoryMockBalanceParams
	mutex    sync.RWMutex
}

// IRepositoryMockBalanceExpectation specifies expectation struct of the IRepository.Balance
type IRepositoryMockBalanceExpectation struct {
	mock    *IRepositoryMock
	params  *IRepositoryMockBalanceParams
	results *IRepositoryMockBalanceResults
	Counter uint64
}

// IRepositoryMockBalanceParams contains parameters of the IRepository.Balance
type IRepositoryMockBalanceParams struct {
	userID uuid.UUID
}

// IRepositoryMockBalanceResults contains results of the IRepository.Balance
type IRepositoryMockBalanceResults struct {
	up1 *model.User
	err error
}

// Expect sets up expected params for IRepository.Balance
func (mmBalance *mIRepositoryMockBalance) Expect(userID uuid.UUID) *mIRepositoryMockBalance {
	if mmBalance.mock.funcBalance != nil {
		mmBalance.mock.t.Fatalf("IRepositoryMock.Balance mock is already set by Set")
	}

	if mmBalance.defaultExpectation == nil {
		mmBalance.defaultExpectation = &IRepositoryMockBalanceExpectation{}
	}

	mmBalance.defaultExpectation.params = &IRepositoryMockBalanceParams{userID}
	for _, e := range mmBalance.expectations {
		if minimock.Equal(e.params, mmBalance.defaultExpectation.params) {
			mmBalance.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBalance.defaultExpectation.params)
		}
	}

	return mmBalance
}

// Inspect accepts an inspector function that has same arguments as the IRepository.Balance
func (mmBalance *mIRepositoryMockBalance) Inspect(f func(userID uuid.UUID)) *mIRepositoryMockBalance {
	if mmBalance.mock.inspectFuncBalance != nil {
		mmBalance.mock.t.Fatalf("Inspect function is already set for IRepositoryMock.Balance")
	}

	mmBalance.mock.inspectFuncBalance = f

	return mmBalance
}

// Return sets up results that will be returned by IRepository.Balance
func (mmBalance *mIRepositoryMockBalance) Return(up1 *model.User, err error) *IRepositoryMock {
	if mmBalance.mock.funcBalance != nil {
		mmBalance.mock.t.Fatalf("IRepositoryMock.Balance mock is already set by Set")
	}

	if mmBalance.defaultExpectation == nil {
		mmBalance.defaultExpectation = &IRepositoryMockBalanceExpectation{mock: mmBalance.mock}
	}
	mmBalance.defaultExpectation.results = &IRepositoryMockBalanceResults{up1, err}
	return mmBalance.mock
}

//Set uses given function f to mock the IRepository.Balance method
func (mmBalance *mIRepositoryMockBalance) Set(f func(userID uuid.UUID) (up1 *model.User, err error)) *IRepositoryMock {
	if mmBalance.defaultExpectation != nil {
		mmBalance.mock.t.Fatalf("Default expectation is already set for the IRepository.Balance method")
	}

	if len(mmBalance.expectations) > 0 {
		mmBalance.mock.t.Fatalf("Some expectations are already set for the IRepository.Balance method")
	}

	mmBalance.mock.funcBalance = f
	return mmBalance.mock
}

// When sets expectation for the IRepository.Balance which will trigger the result defined by the following
// Then helper
func (mmBalance *mIRepositoryMockBalance) When(userID uuid.UUID) *IRepositoryMockBalanceExpectation {
	if mmBalance.mock.funcBalance != nil {
		mmBalance.mock.t.Fatalf("IRepositoryMock.Balance mock is already set by Set")
	}

	expectation := &IRepositoryMockBalanceExpectation{
		mock:   mmBalance.mock,
		params: &IRepositoryMockBalanceParams{userID},
	}
	mmBalance.expectations = append(mmBalance.expectations, expectation)
	return expectation
}

// Then sets up IRepository.Balance return parameters for the expectation previously defined by the When method
func (e *IRepositoryMockBalanceExpectation) Then(up1 *model.User, err error) *IRepositoryMock {
	e.results = &IRepositoryMockBalanceResults{up1, err}
	return e.mock
}

// Balance implements IRepository
func (mmBalance *IRepositoryMock) Balance(userID uuid.UUID) (up1 *model.User, err error) {
	mm_atomic.AddUint64(&mmBalance.beforeBalanceCounter, 1)
	defer mm_atomic.AddUint64(&mmBalance.afterBalanceCounter, 1)

	if mmBalance.inspectFuncBalance != nil {
		mmBalance.inspectFuncBalance(userID)
	}

	mm_params := &IRepositoryMockBalanceParams{userID}

	// Record call args
	mmBalance.BalanceMock.mutex.Lock()
	mmBalance.BalanceMock.callArgs = append(mmBalance.BalanceMock.callArgs, mm_params)
	mmBalance.BalanceMock.mutex.Unlock()

	for _, e := range mmBalance.BalanceMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmBalance.BalanceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBalance.BalanceMock.defaultExpectation.Counter, 1)
		mm_want := mmBalance.BalanceMock.defaultExpectation.params
		mm_got := IRepositoryMockBalanceParams{userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBalance.t.Errorf("IRepositoryMock.Balance got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBalance.BalanceMock.defaultExpectation.results
		if mm_results == nil {
			mmBalance.t.Fatal("No results are set for the IRepositoryMock.Balance")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmBalance.funcBalance != nil {
		return mmBalance.funcBalance(userID)
	}
	mmBalance.t.Fatalf("Unexpected call to IRepositoryMock.Balance. %v", userID)
	return
}

// BalanceAfterCounter returns a count of finished IRepositoryMock.Balance invocations
func (mmBalance *IRepositoryMock) BalanceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBalance.afterBalanceCounter)
}

// BalanceBeforeCounter returns a count of IRepositoryMock.Balance invocations
func (mmBalance *IRepositoryMock) BalanceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBalance.beforeBalanceCounter)
}

// Calls returns a list of arguments used in each call to IRepositoryMock.Balance.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBalance *mIRepositoryMockBalance) Calls() []*IRepositoryMockBalanceParams {
	mmBalance.mutex.RLock()

	argCopy := make([]*IRepositoryMockBalanceParams, len(mmBalance.callArgs))
	copy(argCopy, mmBalance.callArgs)

	mmBalance.mutex.RUnlock()

	return argCopy
}

// MinimockBalanceDone returns true if the count of the Balance invocations corresponds
// the number of defined expectations
func (m *IRepositoryMock) MinimockBalanceDone() bool {
	for _, e := range m.BalanceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BalanceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBalanceCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBalance != nil && mm_atomic.LoadUint64(&m.afterBalanceCounter) < 1 {
		return false
	}
	return true
}

// MinimockBalanceInspect logs each unmet expectation
func (m *IRepositoryMock) MinimockBalanceInspect() {
	for _, e := range m.BalanceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IRepositoryMock.Balance with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BalanceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBalanceCounter) < 1 {
		if m.BalanceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IRepositoryMock.Balance")
		} else {
			m.t.Errorf("Expected call to IRepositoryMock.Balance with params: %#v", *m.BalanceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBalance != nil && mm_atomic.LoadUint64(&m.afterBalanceCounter) < 1 {
		m.t.Error("Expected call to IRepositoryMock.Balance")
	}
}

type mIRepositoryMockEnrollment struct {
	mock               *IRepositoryMock
	defaultExpectation *IRepositoryMockEnrollmentExpectation
	expectations       []*IRepositoryMockEnrollmentExpectation

	callArgs []*IRepositoryMockEnrollmentParams
	mutex    sync.RWMutex
}

// IRepositoryMockEnrollmentExpectation specifies expectation struct of the IRepository.Enrollment
type IRepositoryMockEnrollmentExpectation struct {
	mock    *IRepositoryMock
	params  *IRepositoryMockEnrollmentParams
	results *IRepositoryMockEnrollmentResults
	Counter uint64
}

// IRepositoryMockEnrollmentParams contains parameters of the IRepository.Enrollment
type IRepositoryMockEnrollmentParams struct {
	user  model.User
	funds float64
}

// IRepositoryMockEnrollmentResults contains results of the IRepository.Enrollment
type IRepositoryMockEnrollmentResults struct {
	err error
}

// Expect sets up expected params for IRepository.Enrollment
func (mmEnrollment *mIRepositoryMockEnrollment) Expect(user model.User, funds float64) *mIRepositoryMockEnrollment {
	if mmEnrollment.mock.funcEnrollment != nil {
		mmEnrollment.mock.t.Fatalf("IRepositoryMock.Enrollment mock is already set by Set")
	}

	if mmEnrollment.defaultExpectation == nil {
		mmEnrollment.defaultExpectation = &IRepositoryMockEnrollmentExpectation{}
	}

	mmEnrollment.defaultExpectation.params = &IRepositoryMockEnrollmentParams{user, funds}
	for _, e := range mmEnrollment.expectations {
		if minimock.Equal(e.params, mmEnrollment.defaultExpectation.params) {
			mmEnrollment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEnrollment.defaultExpectation.params)
		}
	}

	return mmEnrollment
}

// Inspect accepts an inspector function that has same arguments as the IRepository.Enrollment
func (mmEnrollment *mIRepositoryMockEnrollment) Inspect(f func(user model.User, funds float64)) *mIRepositoryMockEnrollment {
	if mmEnrollment.mock.inspectFuncEnrollment != nil {
		mmEnrollment.mock.t.Fatalf("Inspect function is already set for IRepositoryMock.Enrollment")
	}

	mmEnrollment.mock.inspectFuncEnrollment = f

	return mmEnrollment
}

// Return sets up results that will be returned by IRepository.Enrollment
func (mmEnrollment *mIRepositoryMockEnrollment) Return(err error) *IRepositoryMock {
	if mmEnrollment.mock.funcEnrollment != nil {
		mmEnrollment.mock.t.Fatalf("IRepositoryMock.Enrollment mock is already set by Set")
	}

	if mmEnrollment.defaultExpectation == nil {
		mmEnrollment.defaultExpectation = &IRepositoryMockEnrollmentExpectation{mock: mmEnrollment.mock}
	}
	mmEnrollment.defaultExpectation.results = &IRepositoryMockEnrollmentResults{err}
	return mmEnrollment.mock
}

//Set uses given function f to mock the IRepository.Enrollment method
func (mmEnrollment *mIRepositoryMockEnrollment) Set(f func(user model.User, funds float64) (err error)) *IRepositoryMock {
	if mmEnrollment.defaultExpectation != nil {
		mmEnrollment.mock.t.Fatalf("Default expectation is already set for the IRepository.Enrollment method")
	}

	if len(mmEnrollment.expectations) > 0 {
		mmEnrollment.mock.t.Fatalf("Some expectations are already set for the IRepository.Enrollment method")
	}

	mmEnrollment.mock.funcEnrollment = f
	return mmEnrollment.mock
}

// When sets expectation for the IRepository.Enrollment which will trigger the result defined by the following
// Then helper
func (mmEnrollment *mIRepositoryMockEnrollment) When(user model.User, funds float64) *IRepositoryMockEnrollmentExpectation {
	if mmEnrollment.mock.funcEnrollment != nil {
		mmEnrollment.mock.t.Fatalf("IRepositoryMock.Enrollment mock is already set by Set")
	}

	expectation := &IRepositoryMockEnrollmentExpectation{
		mock:   mmEnrollment.mock,
		params: &IRepositoryMockEnrollmentParams{user, funds},
	}
	mmEnrollment.expectations = append(mmEnrollment.expectations, expectation)
	return expectation
}

// Then sets up IRepository.Enrollment return parameters for the expectation previously defined by the When method
func (e *IRepositoryMockEnrollmentExpectation) Then(err error) *IRepositoryMock {
	e.results = &IRepositoryMockEnrollmentResults{err}
	return e.mock
}

// Enrollment implements IRepository
func (mmEnrollment *IRepositoryMock) Enrollment(user model.User, funds float64) (err error) {
	mm_atomic.AddUint64(&mmEnrollment.beforeEnrollmentCounter, 1)
	defer mm_atomic.AddUint64(&mmEnrollment.afterEnrollmentCounter, 1)

	if mmEnrollment.inspectFuncEnrollment != nil {
		mmEnrollment.inspectFuncEnrollment(user, funds)
	}

	mm_params := &IRepositoryMockEnrollmentParams{user, funds}

	// Record call args
	mmEnrollment.EnrollmentMock.mutex.Lock()
	mmEnrollment.EnrollmentMock.callArgs = append(mmEnrollment.EnrollmentMock.callArgs, mm_params)
	mmEnrollment.EnrollmentMock.mutex.Unlock()

	for _, e := range mmEnrollment.EnrollmentMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmEnrollment.EnrollmentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEnrollment.EnrollmentMock.defaultExpectation.Counter, 1)
		mm_want := mmEnrollment.EnrollmentMock.defaultExpectation.params
		mm_got := IRepositoryMockEnrollmentParams{user, funds}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEnrollment.t.Errorf("IRepositoryMock.Enrollment got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEnrollment.EnrollmentMock.defaultExpectation.results
		if mm_results == nil {
			mmEnrollment.t.Fatal("No results are set for the IRepositoryMock.Enrollment")
		}
		return (*mm_results).err
	}
	if mmEnrollment.funcEnrollment != nil {
		return mmEnrollment.funcEnrollment(user, funds)
	}
	mmEnrollment.t.Fatalf("Unexpected call to IRepositoryMock.Enrollment. %v %v", user, funds)
	return
}

// EnrollmentAfterCounter returns a count of finished IRepositoryMock.Enrollment invocations
func (mmEnrollment *IRepositoryMock) EnrollmentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEnrollment.afterEnrollmentCounter)
}

// EnrollmentBeforeCounter returns a count of IRepositoryMock.Enrollment invocations
func (mmEnrollment *IRepositoryMock) EnrollmentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEnrollment.beforeEnrollmentCounter)
}

// Calls returns a list of arguments used in each call to IRepositoryMock.Enrollment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEnrollment *mIRepositoryMockEnrollment) Calls() []*IRepositoryMockEnrollmentParams {
	mmEnrollment.mutex.RLock()

	argCopy := make([]*IRepositoryMockEnrollmentParams, len(mmEnrollment.callArgs))
	copy(argCopy, mmEnrollment.callArgs)

	mmEnrollment.mutex.RUnlock()

	return argCopy
}

// MinimockEnrollmentDone returns true if the count of the Enrollment invocations corresponds
// the number of defined expectations
func (m *IRepositoryMock) MinimockEnrollmentDone() bool {
	for _, e := range m.EnrollmentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EnrollmentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEnrollmentCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEnrollment != nil && mm_atomic.LoadUint64(&m.afterEnrollmentCounter) < 1 {
		return false
	}
	return true
}

// MinimockEnrollmentInspect logs each unmet expectation
func (m *IRepositoryMock) MinimockEnrollmentInspect() {
	for _, e := range m.EnrollmentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IRepositoryMock.Enrollment with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EnrollmentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEnrollmentCounter) < 1 {
		if m.EnrollmentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IRepositoryMock.Enrollment")
		} else {
			m.t.Errorf("Expected call to IRepositoryMock.Enrollment with params: %#v", *m.EnrollmentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEnrollment != nil && mm_atomic.LoadUint64(&m.afterEnrollmentCounter) < 1 {
		m.t.Error("Expected call to IRepositoryMock.Enrollment")
	}
}

type mIRepositoryMockGetOrder struct {
	mock               *IRepositoryMock
	defaultExpectation *IRepositoryMockGetOrderExpectation
	expectations       []*IRepositoryMockGetOrderExpectation

	callArgs []*IRepositoryMockGetOrderParams
	mutex    sync.RWMutex
}

// IRepositoryMockGetOrderExpectation specifies expectation struct of the IRepository.GetOrder
type IRepositoryMockGetOrderExpectation struct {
	mock    *IRepositoryMock
	params  *IRepositoryMockGetOrderParams
	results *IRepositoryMockGetOrderResults
	Counter uint64
}

// IRepositoryMockGetOrderParams contains parameters of the IRepository.GetOrder
type IRepositoryMockGetOrderParams struct {
	orderID uuid.UUID
}

// IRepositoryMockGetOrderResults contains results of the IRepository.GetOrder
type IRepositoryMockGetOrderResults struct {
	op1 *model.Order
	err error
}

// Expect sets up expected params for IRepository.GetOrder
func (mmGetOrder *mIRepositoryMockGetOrder) Expect(orderID uuid.UUID) *mIRepositoryMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("IRepositoryMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &IRepositoryMockGetOrderExpectation{}
	}

	mmGetOrder.defaultExpectation.params = &IRepositoryMockGetOrderParams{orderID}
	for _, e := range mmGetOrder.expectations {
		if minimock.Equal(e.params, mmGetOrder.defaultExpectation.params) {
			mmGetOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrder.defaultExpectation.params)
		}
	}

	return mmGetOrder
}

// Inspect accepts an inspector function that has same arguments as the IRepository.GetOrder
func (mmGetOrder *mIRepositoryMockGetOrder) Inspect(f func(orderID uuid.UUID)) *mIRepositoryMockGetOrder {
	if mmGetOrder.mock.inspectFuncGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("Inspect function is already set for IRepositoryMock.GetOrder")
	}

	mmGetOrder.mock.inspectFuncGetOrder = f

	return mmGetOrder
}

// Return sets up results that will be returned by IRepository.GetOrder
func (mmGetOrder *mIRepositoryMockGetOrder) Return(op1 *model.Order, err error) *IRepositoryMock {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("IRepositoryMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &IRepositoryMockGetOrderExpectation{mock: mmGetOrder.mock}
	}
	mmGetOrder.defaultExpectation.results = &IRepositoryMockGetOrderResults{op1, err}
	return mmGetOrder.mock
}

//Set uses given function f to mock the IRepository.GetOrder method
func (mmGetOrder *mIRepositoryMockGetOrder) Set(f func(orderID uuid.UUID) (op1 *model.Order, err error)) *IRepositoryMock {
	if mmGetOrder.defaultExpectation != nil {
		mmGetOrder.mock.t.Fatalf("Default expectation is already set for the IRepository.GetOrder method")
	}

	if len(mmGetOrder.expectations) > 0 {
		mmGetOrder.mock.t.Fatalf("Some expectations are already set for the IRepository.GetOrder method")
	}

	mmGetOrder.mock.funcGetOrder = f
	return mmGetOrder.mock
}

// When sets expectation for the IRepository.GetOrder which will trigger the result defined by the following
// Then helper
func (mmGetOrder *mIRepositoryMockGetOrder) When(orderID uuid.UUID) *IRepositoryMockGetOrderExpectation {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("IRepositoryMock.GetOrder mock is already set by Set")
	}

	expectation := &IRepositoryMockGetOrderExpectation{
		mock:   mmGetOrder.mock,
		params: &IRepositoryMockGetOrderParams{orderID},
	}
	mmGetOrder.expectations = append(mmGetOrder.expectations, expectation)
	return expectation
}

// Then sets up IRepository.GetOrder return parameters for the expectation previously defined by the When method
func (e *IRepositoryMockGetOrderExpectation) Then(op1 *model.Order, err error) *IRepositoryMock {
	e.results = &IRepositoryMockGetOrderResults{op1, err}
	return e.mock
}

// GetOrder implements IRepository
func (mmGetOrder *IRepositoryMock) GetOrder(orderID uuid.UUID) (op1 *model.Order, err error) {
	mm_atomic.AddUint64(&mmGetOrder.beforeGetOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrder.afterGetOrderCounter, 1)

	if mmGetOrder.inspectFuncGetOrder != nil {
		mmGetOrder.inspectFuncGetOrder(orderID)
	}

	mm_params := &IRepositoryMockGetOrderParams{orderID}

	// Record call args
	mmGetOrder.GetOrderMock.mutex.Lock()
	mmGetOrder.GetOrderMock.callArgs = append(mmGetOrder.GetOrderMock.callArgs, mm_params)
	mmGetOrder.GetOrderMock.mutex.Unlock()

	for _, e := range mmGetOrder.GetOrderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetOrder.GetOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrder.GetOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrder.GetOrderMock.defaultExpectation.params
		mm_got := IRepositoryMockGetOrderParams{orderID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrder.t.Errorf("IRepositoryMock.GetOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrder.GetOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrder.t.Fatal("No results are set for the IRepositoryMock.GetOrder")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetOrder.funcGetOrder != nil {
		return mmGetOrder.funcGetOrder(orderID)
	}
	mmGetOrder.t.Fatalf("Unexpected call to IRepositoryMock.GetOrder. %v", orderID)
	return
}

// GetOrderAfterCounter returns a count of finished IRepositoryMock.GetOrder invocations
func (mmGetOrder *IRepositoryMock) GetOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrder.afterGetOrderCounter)
}

// GetOrderBeforeCounter returns a count of IRepositoryMock.GetOrder invocations
func (mmGetOrder *IRepositoryMock) GetOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrder.beforeGetOrderCounter)
}

// Calls returns a list of arguments used in each call to IRepositoryMock.GetOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrder *mIRepositoryMockGetOrder) Calls() []*IRepositoryMockGetOrderParams {
	mmGetOrder.mutex.RLock()

	argCopy := make([]*IRepositoryMockGetOrderParams, len(mmGetOrder.callArgs))
	copy(argCopy, mmGetOrder.callArgs)

	mmGetOrder.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrderDone returns true if the count of the GetOrder invocations corresponds
// the number of defined expectations
func (m *IRepositoryMock) MinimockGetOrderDone() bool {
	for _, e := range m.GetOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrder != nil && mm_atomic.LoadUint64(&m.afterGetOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetOrderInspect logs each unmet expectation
func (m *IRepositoryMock) MinimockGetOrderInspect() {
	for _, e := range m.GetOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IRepositoryMock.GetOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOrderCounter) < 1 {
		if m.GetOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IRepositoryMock.GetOrder")
		} else {
			m.t.Errorf("Expected call to IRepositoryMock.GetOrder with params: %#v", *m.GetOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrder != nil && mm_atomic.LoadUint64(&m.afterGetOrderCounter) < 1 {
		m.t.Error("Expected call to IRepositoryMock.GetOrder")
	}
}

type mIRepositoryMockHistory struct {
	mock               *IRepositoryMock
	defaultExpectation *IRepositoryMockHistoryExpectation
	expectations       []*IRepositoryMockHistoryExpectation

	callArgs []*IRepositoryMockHistoryParams
	mutex    sync.RWMutex
}

// IRepositoryMockHistoryExpectation specifies expectation struct of the IRepository.History
type IRepositoryMockHistoryExpectation struct {
	mock    *IRepositoryMock
	params  *IRepositoryMockHistoryParams
	results *IRepositoryMockHistoryResults
	Counter uint64
}

// IRepositoryMockHistoryParams contains parameters of the IRepository.History
type IRepositoryMockHistoryParams struct {
	userID uuid.UUID
	limit  int
	offset int
}

// IRepositoryMockHistoryResults contains results of the IRepository.History
type IRepositoryMockHistoryResults struct {
	ha1 []model.History
	err error
}

// Expect sets up expected params for IRepository.History
func (mmHistory *mIRepositoryMockHistory) Expect(userID uuid.UUID, limit int, offset int) *mIRepositoryMockHistory {
	if mmHistory.mock.funcHistory != nil {
		mmHistory.mock.t.Fatalf("IRepositoryMock.History mock is already set by Set")
	}

	if mmHistory.defaultExpectation == nil {
		mmHistory.defaultExpectation = &IRepositoryMockHistoryExpectation{}
	}

	mmHistory.defaultExpectation.params = &IRepositoryMockHistoryParams{userID, limit, offset}
	for _, e := range mmHistory.expectations {
		if minimock.Equal(e.params, mmHistory.defaultExpectation.params) {
			mmHistory.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHistory.defaultExpectation.params)
		}
	}

	return mmHistory
}

// Inspect accepts an inspector function that has same arguments as the IRepository.History
func (mmHistory *mIRepositoryMockHistory) Inspect(f func(userID uuid.UUID, limit int, offset int)) *mIRepositoryMockHistory {
	if mmHistory.mock.inspectFuncHistory != nil {
		mmHistory.mock.t.Fatalf("Inspect function is already set for IRepositoryMock.History")
	}

	mmHistory.mock.inspectFuncHistory = f

	return mmHistory
}

// Return sets up results that will be returned by IRepository.History
func (mmHistory *mIRepositoryMockHistory) Return(ha1 []model.History, err error) *IRepositoryMock {
	if mmHistory.mock.funcHistory != nil {
		mmHistory.mock.t.Fatalf("IRepositoryMock.History mock is already set by Set")
	}

	if mmHistory.defaultExpectation == nil {
		mmHistory.defaultExpectation = &IRepositoryMockHistoryExpectation{mock: mmHistory.mock}
	}
	mmHistory.defaultExpectation.results = &IRepositoryMockHistoryResults{ha1, err}
	return mmHistory.mock
}

//Set uses given function f to mock the IRepository.History method
func (mmHistory *mIRepositoryMockHistory) Set(f func(userID uuid.UUID, limit int, offset int) (ha1 []model.History, err error)) *IRepositoryMock {
	if mmHistory.defaultExpectation != nil {
		mmHistory.mock.t.Fatalf("Default expectation is already set for the IRepository.History method")
	}

	if len(mmHistory.expectations) > 0 {
		mmHistory.mock.t.Fatalf("Some expectations are already set for the IRepository.History method")
	}

	mmHistory.mock.funcHistory = f
	return mmHistory.mock
}

// When sets expectation for the IRepository.History which will trigger the result defined by the following
// Then helper
func (mmHistory *mIRepositoryMockHistory) When(userID uuid.UUID, limit int, offset int) *IRepositoryMockHistoryExpectation {
	if mmHistory.mock.funcHistory != nil {
		mmHistory.mock.t.Fatalf("IRepositoryMock.History mock is already set by Set")
	}

	expectation := &IRepositoryMockHistoryExpectation{
		mock:   mmHistory.mock,
		params: &IRepositoryMockHistoryParams{userID, limit, offset},
	}
	mmHistory.expectations = append(mmHistory.expectations, expectation)
	return expectation
}

// Then sets up IRepository.History return parameters for the expectation previously defined by the When method
func (e *IRepositoryMockHistoryExpectation) Then(ha1 []model.History, err error) *IRepositoryMock {
	e.results = &IRepositoryMockHistoryResults{ha1, err}
	return e.mock
}

// History implements IRepository
func (mmHistory *IRepositoryMock) History(userID uuid.UUID, limit int, offset int) (ha1 []model.History, err error) {
	mm_atomic.AddUint64(&mmHistory.beforeHistoryCounter, 1)
	defer mm_atomic.AddUint64(&mmHistory.afterHistoryCounter, 1)

	if mmHistory.inspectFuncHistory != nil {
		mmHistory.inspectFuncHistory(userID, limit, offset)
	}

	mm_params := &IRepositoryMockHistoryParams{userID, limit, offset}

	// Record call args
	mmHistory.HistoryMock.mutex.Lock()
	mmHistory.HistoryMock.callArgs = append(mmHistory.HistoryMock.callArgs, mm_params)
	mmHistory.HistoryMock.mutex.Unlock()

	for _, e := range mmHistory.HistoryMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ha1, e.results.err
		}
	}

	if mmHistory.HistoryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHistory.HistoryMock.defaultExpectation.Counter, 1)
		mm_want := mmHistory.HistoryMock.defaultExpectation.params
		mm_got := IRepositoryMockHistoryParams{userID, limit, offset}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHistory.t.Errorf("IRepositoryMock.History got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHistory.HistoryMock.defaultExpectation.results
		if mm_results == nil {
			mmHistory.t.Fatal("No results are set for the IRepositoryMock.History")
		}
		return (*mm_results).ha1, (*mm_results).err
	}
	if mmHistory.funcHistory != nil {
		return mmHistory.funcHistory(userID, limit, offset)
	}
	mmHistory.t.Fatalf("Unexpected call to IRepositoryMock.History. %v %v %v", userID, limit, offset)
	return
}

// HistoryAfterCounter returns a count of finished IRepositoryMock.History invocations
func (mmHistory *IRepositoryMock) HistoryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHistory.afterHistoryCounter)
}

// HistoryBeforeCounter returns a count of IRepositoryMock.History invocations
func (mmHistory *IRepositoryMock) HistoryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHistory.beforeHistoryCounter)
}

// Calls returns a list of arguments used in each call to IRepositoryMock.History.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHistory *mIRepositoryMockHistory) Calls() []*IRepositoryMockHistoryParams {
	mmHistory.mutex.RLock()

	argCopy := make([]*IRepositoryMockHistoryParams, len(mmHistory.callArgs))
	copy(argCopy, mmHistory.callArgs)

	mmHistory.mutex.RUnlock()

	return argCopy
}

// MinimockHistoryDone returns true if the count of the History invocations corresponds
// the number of defined expectations
func (m *IRepositoryMock) MinimockHistoryDone() bool {
	for _, e := range m.HistoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HistoryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHistoryCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHistory != nil && mm_atomic.LoadUint64(&m.afterHistoryCounter) < 1 {
		return false
	}
	return true
}

// MinimockHistoryInspect logs each unmet expectation
func (m *IRepositoryMock) MinimockHistoryInspect() {
	for _, e := range m.HistoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IRepositoryMock.History with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HistoryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHistoryCounter) < 1 {
		if m.HistoryMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IRepositoryMock.History")
		} else {
			m.t.Errorf("Expected call to IRepositoryMock.History with params: %#v", *m.HistoryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHistory != nil && mm_atomic.LoadUint64(&m.afterHistoryCounter) < 1 {
		m.t.Error("Expected call to IRepositoryMock.History")
	}
}

type mIRepositoryMockOrder struct {
	mock               *IRepositoryMock
	defaultExpectation *IRepositoryMockOrderExpectation
	expectations       []*IRepositoryMockOrderExpectation

	callArgs []*IRepositoryMockOrderParams
	mutex    sync.RWMutex
}

// IRepositoryMockOrderExpectation specifies expectation struct of the IRepository.Order
type IRepositoryMockOrderExpectation struct {
	mock    *IRepositoryMock
	params  *IRepositoryMockOrderParams
	results *IRepositoryMockOrderResults
	Counter uint64
}

// IRepositoryMockOrderParams contains parameters of the IRepository.Order
type IRepositoryMockOrderParams struct {
	user  model.User
	order model.Order
}

// IRepositoryMockOrderResults contains results of the IRepository.Order
type IRepositoryMockOrderResults struct {
	err error
}

// Expect sets up expected params for IRepository.Order
func (mmOrder *mIRepositoryMockOrder) Expect(user model.User, order model.Order) *mIRepositoryMockOrder {
	if mmOrder.mock.funcOrder != nil {
		mmOrder.mock.t.Fatalf("IRepositoryMock.Order mock is already set by Set")
	}

	if mmOrder.defaultExpectation == nil {
		mmOrder.defaultExpectation = &IRepositoryMockOrderExpectation{}
	}

	mmOrder.defaultExpectation.params = &IRepositoryMockOrderParams{user, order}
	for _, e := range mmOrder.expectations {
		if minimock.Equal(e.params, mmOrder.defaultExpectation.params) {
			mmOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrder.defaultExpectation.params)
		}
	}

	return mmOrder
}

// Inspect accepts an inspector function that has same arguments as the IRepository.Order
func (mmOrder *mIRepositoryMockOrder) Inspect(f func(user model.User, order model.Order)) *mIRepositoryMockOrder {
	if mmOrder.mock.inspectFuncOrder != nil {
		mmOrder.mock.t.Fatalf("Inspect function is already set for IRepositoryMock.Order")
	}

	mmOrder.mock.inspectFuncOrder = f

	return mmOrder
}

// Return sets up results that will be returned by IRepository.Order
func (mmOrder *mIRepositoryMockOrder) Return(err error) *IRepositoryMock {
	if mmOrder.mock.funcOrder != nil {
		mmOrder.mock.t.Fatalf("IRepositoryMock.Order mock is already set by Set")
	}

	if mmOrder.defaultExpectation == nil {
		mmOrder.defaultExpectation = &IRepositoryMockOrderExpectation{mock: mmOrder.mock}
	}
	mmOrder.defaultExpectation.results = &IRepositoryMockOrderResults{err}
	return mmOrder.mock
}

//Set uses given function f to mock the IRepository.Order method
func (mmOrder *mIRepositoryMockOrder) Set(f func(user model.User, order model.Order) (err error)) *IRepositoryMock {
	if mmOrder.defaultExpectation != nil {
		mmOrder.mock.t.Fatalf("Default expectation is already set for the IRepository.Order method")
	}

	if len(mmOrder.expectations) > 0 {
		mmOrder.mock.t.Fatalf("Some expectations are already set for the IRepository.Order method")
	}

	mmOrder.mock.funcOrder = f
	return mmOrder.mock
}

// When sets expectation for the IRepository.Order which will trigger the result defined by the following
// Then helper
func (mmOrder *mIRepositoryMockOrder) When(user model.User, order model.Order) *IRepositoryMockOrderExpectation {
	if mmOrder.mock.funcOrder != nil {
		mmOrder.mock.t.Fatalf("IRepositoryMock.Order mock is already set by Set")
	}

	expectation := &IRepositoryMockOrderExpectation{
		mock:   mmOrder.mock,
		params: &IRepositoryMockOrderParams{user, order},
	}
	mmOrder.expectations = append(mmOrder.expectations, expectation)
	return expectation
}

// Then sets up IRepository.Order return parameters for the expectation previously defined by the When method
func (e *IRepositoryMockOrderExpectation) Then(err error) *IRepositoryMock {
	e.results = &IRepositoryMockOrderResults{err}
	return e.mock
}

// Order implements IRepository
func (mmOrder *IRepositoryMock) Order(user model.User, order model.Order) (err error) {
	mm_atomic.AddUint64(&mmOrder.beforeOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmOrder.afterOrderCounter, 1)

	if mmOrder.inspectFuncOrder != nil {
		mmOrder.inspectFuncOrder(user, order)
	}

	mm_params := &IRepositoryMockOrderParams{user, order}

	// Record call args
	mmOrder.OrderMock.mutex.Lock()
	mmOrder.OrderMock.callArgs = append(mmOrder.OrderMock.callArgs, mm_params)
	mmOrder.OrderMock.mutex.Unlock()

	for _, e := range mmOrder.OrderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmOrder.OrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrder.OrderMock.defaultExpectation.Counter, 1)
		mm_want := mmOrder.OrderMock.defaultExpectation.params
		mm_got := IRepositoryMockOrderParams{user, order}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrder.t.Errorf("IRepositoryMock.Order got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrder.OrderMock.defaultExpectation.results
		if mm_results == nil {
			mmOrder.t.Fatal("No results are set for the IRepositoryMock.Order")
		}
		return (*mm_results).err
	}
	if mmOrder.funcOrder != nil {
		return mmOrder.funcOrder(user, order)
	}
	mmOrder.t.Fatalf("Unexpected call to IRepositoryMock.Order. %v %v", user, order)
	return
}

// OrderAfterCounter returns a count of finished IRepositoryMock.Order invocations
func (mmOrder *IRepositoryMock) OrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrder.afterOrderCounter)
}

// OrderBeforeCounter returns a count of IRepositoryMock.Order invocations
func (mmOrder *IRepositoryMock) OrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrder.beforeOrderCounter)
}

// Calls returns a list of arguments used in each call to IRepositoryMock.Order.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrder *mIRepositoryMockOrder) Calls() []*IRepositoryMockOrderParams {
	mmOrder.mutex.RLock()

	argCopy := make([]*IRepositoryMockOrderParams, len(mmOrder.callArgs))
	copy(argCopy, mmOrder.callArgs)

	mmOrder.mutex.RUnlock()

	return argCopy
}

// MinimockOrderDone returns true if the count of the Order invocations corresponds
// the number of defined expectations
func (m *IRepositoryMock) MinimockOrderDone() bool {
	for _, e := range m.OrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrder != nil && mm_atomic.LoadUint64(&m.afterOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockOrderInspect logs each unmet expectation
func (m *IRepositoryMock) MinimockOrderInspect() {
	for _, e := range m.OrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IRepositoryMock.Order with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOrderCounter) < 1 {
		if m.OrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IRepositoryMock.Order")
		} else {
			m.t.Errorf("Expected call to IRepositoryMock.Order with params: %#v", *m.OrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrder != nil && mm_atomic.LoadUint64(&m.afterOrderCounter) < 1 {
		m.t.Error("Expected call to IRepositoryMock.Order")
	}
}

type mIRepositoryMockOrderFailed struct {
	mock               *IRepositoryMock
	defaultExpectation *IRepositoryMockOrderFailedExpectation
	expectations       []*IRepositoryMockOrderFailedExpectation

	callArgs []*IRepositoryMockOrderFailedParams
	mutex    sync.RWMutex
}

// IRepositoryMockOrderFailedExpectation specifies expectation struct of the IRepository.OrderFailed
type IRepositoryMockOrderFailedExpectation struct {
	mock    *IRepositoryMock
	params  *IRepositoryMockOrderFailedParams
	results *IRepositoryMockOrderFailedResults
	Counter uint64
}

// IRepositoryMockOrderFailedParams contains parameters of the IRepository.OrderFailed
type IRepositoryMockOrderFailedParams struct {
	user  model.User
	order model.Order
}

// IRepositoryMockOrderFailedResults contains results of the IRepository.OrderFailed
type IRepositoryMockOrderFailedResults struct {
	err error
}

// Expect sets up expected params for IRepository.OrderFailed
func (mmOrderFailed *mIRepositoryMockOrderFailed) Expect(user model.User, order model.Order) *mIRepositoryMockOrderFailed {
	if mmOrderFailed.mock.funcOrderFailed != nil {
		mmOrderFailed.mock.t.Fatalf("IRepositoryMock.OrderFailed mock is already set by Set")
	}

	if mmOrderFailed.defaultExpectation == nil {
		mmOrderFailed.defaultExpectation = &IRepositoryMockOrderFailedExpectation{}
	}

	mmOrderFailed.defaultExpectation.params = &IRepositoryMockOrderFailedParams{user, order}
	for _, e := range mmOrderFailed.expectations {
		if minimock.Equal(e.params, mmOrderFailed.defaultExpectation.params) {
			mmOrderFailed.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrderFailed.defaultExpectation.params)
		}
	}

	return mmOrderFailed
}

// Inspect accepts an inspector function that has same arguments as the IRepository.OrderFailed
func (mmOrderFailed *mIRepositoryMockOrderFailed) Inspect(f func(user model.User, order model.Order)) *mIRepositoryMockOrderFailed {
	if mmOrderFailed.mock.inspectFuncOrderFailed != nil {
		mmOrderFailed.mock.t.Fatalf("Inspect function is already set for IRepositoryMock.OrderFailed")
	}

	mmOrderFailed.mock.inspectFuncOrderFailed = f

	return mmOrderFailed
}

// Return sets up results that will be returned by IRepository.OrderFailed
func (mmOrderFailed *mIRepositoryMockOrderFailed) Return(err error) *IRepositoryMock {
	if mmOrderFailed.mock.funcOrderFailed != nil {
		mmOrderFailed.mock.t.Fatalf("IRepositoryMock.OrderFailed mock is already set by Set")
	}

	if mmOrderFailed.defaultExpectation == nil {
		mmOrderFailed.defaultExpectation = &IRepositoryMockOrderFailedExpectation{mock: mmOrderFailed.mock}
	}
	mmOrderFailed.defaultExpectation.results = &IRepositoryMockOrderFailedResults{err}
	return mmOrderFailed.mock
}

//Set uses given function f to mock the IRepository.OrderFailed method
func (mmOrderFailed *mIRepositoryMockOrderFailed) Set(f func(user model.User, order model.Order) (err error)) *IRepositoryMock {
	if mmOrderFailed.defaultExpectation != nil {
		mmOrderFailed.mock.t.Fatalf("Default expectation is already set for the IRepository.OrderFailed method")
	}

	if len(mmOrderFailed.expectations) > 0 {
		mmOrderFailed.mock.t.Fatalf("Some expectations are already set for the IRepository.OrderFailed method")
	}

	mmOrderFailed.mock.funcOrderFailed = f
	return mmOrderFailed.mock
}

// When sets expectation for the IRepository.OrderFailed which will trigger the result defined by the following
// Then helper
func (mmOrderFailed *mIRepositoryMockOrderFailed) When(user model.User, order model.Order) *IRepositoryMockOrderFailedExpectation {
	if mmOrderFailed.mock.funcOrderFailed != nil {
		mmOrderFailed.mock.t.Fatalf("IRepositoryMock.OrderFailed mock is already set by Set")
	}

	expectation := &IRepositoryMockOrderFailedExpectation{
		mock:   mmOrderFailed.mock,
		params: &IRepositoryMockOrderFailedParams{user, order},
	}
	mmOrderFailed.expectations = append(mmOrderFailed.expectations, expectation)
	return expectation
}

// Then sets up IRepository.OrderFailed return parameters for the expectation previously defined by the When method
func (e *IRepositoryMockOrderFailedExpectation) Then(err error) *IRepositoryMock {
	e.results = &IRepositoryMockOrderFailedResults{err}
	return e.mock
}

// OrderFailed implements IRepository
func (mmOrderFailed *IRepositoryMock) OrderFailed(user model.User, order model.Order) (err error) {
	mm_atomic.AddUint64(&mmOrderFailed.beforeOrderFailedCounter, 1)
	defer mm_atomic.AddUint64(&mmOrderFailed.afterOrderFailedCounter, 1)

	if mmOrderFailed.inspectFuncOrderFailed != nil {
		mmOrderFailed.inspectFuncOrderFailed(user, order)
	}

	mm_params := &IRepositoryMockOrderFailedParams{user, order}

	// Record call args
	mmOrderFailed.OrderFailedMock.mutex.Lock()
	mmOrderFailed.OrderFailedMock.callArgs = append(mmOrderFailed.OrderFailedMock.callArgs, mm_params)
	mmOrderFailed.OrderFailedMock.mutex.Unlock()

	for _, e := range mmOrderFailed.OrderFailedMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmOrderFailed.OrderFailedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrderFailed.OrderFailedMock.defaultExpectation.Counter, 1)
		mm_want := mmOrderFailed.OrderFailedMock.defaultExpectation.params
		mm_got := IRepositoryMockOrderFailedParams{user, order}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrderFailed.t.Errorf("IRepositoryMock.OrderFailed got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrderFailed.OrderFailedMock.defaultExpectation.results
		if mm_results == nil {
			mmOrderFailed.t.Fatal("No results are set for the IRepositoryMock.OrderFailed")
		}
		return (*mm_results).err
	}
	if mmOrderFailed.funcOrderFailed != nil {
		return mmOrderFailed.funcOrderFailed(user, order)
	}
	mmOrderFailed.t.Fatalf("Unexpected call to IRepositoryMock.OrderFailed. %v %v", user, order)
	return
}

// OrderFailedAfterCounter returns a count of finished IRepositoryMock.OrderFailed invocations
func (mmOrderFailed *IRepositoryMock) OrderFailedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderFailed.afterOrderFailedCounter)
}

// OrderFailedBeforeCounter returns a count of IRepositoryMock.OrderFailed invocations
func (mmOrderFailed *IRepositoryMock) OrderFailedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderFailed.beforeOrderFailedCounter)
}

// Calls returns a list of arguments used in each call to IRepositoryMock.OrderFailed.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrderFailed *mIRepositoryMockOrderFailed) Calls() []*IRepositoryMockOrderFailedParams {
	mmOrderFailed.mutex.RLock()

	argCopy := make([]*IRepositoryMockOrderFailedParams, len(mmOrderFailed.callArgs))
	copy(argCopy, mmOrderFailed.callArgs)

	mmOrderFailed.mutex.RUnlock()

	return argCopy
}

// MinimockOrderFailedDone returns true if the count of the OrderFailed invocations corresponds
// the number of defined expectations
func (m *IRepositoryMock) MinimockOrderFailedDone() bool {
	for _, e := range m.OrderFailedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OrderFailedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOrderFailedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderFailed != nil && mm_atomic.LoadUint64(&m.afterOrderFailedCounter) < 1 {
		return false
	}
	return true
}

// MinimockOrderFailedInspect logs each unmet expectation
func (m *IRepositoryMock) MinimockOrderFailedInspect() {
	for _, e := range m.OrderFailedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IRepositoryMock.OrderFailed with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OrderFailedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOrderFailedCounter) < 1 {
		if m.OrderFailedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IRepositoryMock.OrderFailed")
		} else {
			m.t.Errorf("Expected call to IRepositoryMock.OrderFailed with params: %#v", *m.OrderFailedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderFailed != nil && mm_atomic.LoadUint64(&m.afterOrderFailedCounter) < 1 {
		m.t.Error("Expected call to IRepositoryMock.OrderFailed")
	}
}

type mIRepositoryMockOrderSuccess struct {
	mock               *IRepositoryMock
	defaultExpectation *IRepositoryMockOrderSuccessExpectation
	expectations       []*IRepositoryMockOrderSuccessExpectation

	callArgs []*IRepositoryMockOrderSuccessParams
	mutex    sync.RWMutex
}

// IRepositoryMockOrderSuccessExpectation specifies expectation struct of the IRepository.OrderSuccess
type IRepositoryMockOrderSuccessExpectation struct {
	mock    *IRepositoryMock
	params  *IRepositoryMockOrderSuccessParams
	results *IRepositoryMockOrderSuccessResults
	Counter uint64
}

// IRepositoryMockOrderSuccessParams contains parameters of the IRepository.OrderSuccess
type IRepositoryMockOrderSuccessParams struct {
	order model.Order
}

// IRepositoryMockOrderSuccessResults contains results of the IRepository.OrderSuccess
type IRepositoryMockOrderSuccessResults struct {
	err error
}

// Expect sets up expected params for IRepository.OrderSuccess
func (mmOrderSuccess *mIRepositoryMockOrderSuccess) Expect(order model.Order) *mIRepositoryMockOrderSuccess {
	if mmOrderSuccess.mock.funcOrderSuccess != nil {
		mmOrderSuccess.mock.t.Fatalf("IRepositoryMock.OrderSuccess mock is already set by Set")
	}

	if mmOrderSuccess.defaultExpectation == nil {
		mmOrderSuccess.defaultExpectation = &IRepositoryMockOrderSuccessExpectation{}
	}

	mmOrderSuccess.defaultExpectation.params = &IRepositoryMockOrderSuccessParams{order}
	for _, e := range mmOrderSuccess.expectations {
		if minimock.Equal(e.params, mmOrderSuccess.defaultExpectation.params) {
			mmOrderSuccess.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrderSuccess.defaultExpectation.params)
		}
	}

	return mmOrderSuccess
}

// Inspect accepts an inspector function that has same arguments as the IRepository.OrderSuccess
func (mmOrderSuccess *mIRepositoryMockOrderSuccess) Inspect(f func(order model.Order)) *mIRepositoryMockOrderSuccess {
	if mmOrderSuccess.mock.inspectFuncOrderSuccess != nil {
		mmOrderSuccess.mock.t.Fatalf("Inspect function is already set for IRepositoryMock.OrderSuccess")
	}

	mmOrderSuccess.mock.inspectFuncOrderSuccess = f

	return mmOrderSuccess
}

// Return sets up results that will be returned by IRepository.OrderSuccess
func (mmOrderSuccess *mIRepositoryMockOrderSuccess) Return(err error) *IRepositoryMock {
	if mmOrderSuccess.mock.funcOrderSuccess != nil {
		mmOrderSuccess.mock.t.Fatalf("IRepositoryMock.OrderSuccess mock is already set by Set")
	}

	if mmOrderSuccess.defaultExpectation == nil {
		mmOrderSuccess.defaultExpectation = &IRepositoryMockOrderSuccessExpectation{mock: mmOrderSuccess.mock}
	}
	mmOrderSuccess.defaultExpectation.results = &IRepositoryMockOrderSuccessResults{err}
	return mmOrderSuccess.mock
}

//Set uses given function f to mock the IRepository.OrderSuccess method
func (mmOrderSuccess *mIRepositoryMockOrderSuccess) Set(f func(order model.Order) (err error)) *IRepositoryMock {
	if mmOrderSuccess.defaultExpectation != nil {
		mmOrderSuccess.mock.t.Fatalf("Default expectation is already set for the IRepository.OrderSuccess method")
	}

	if len(mmOrderSuccess.expectations) > 0 {
		mmOrderSuccess.mock.t.Fatalf("Some expectations are already set for the IRepository.OrderSuccess method")
	}

	mmOrderSuccess.mock.funcOrderSuccess = f
	return mmOrderSuccess.mock
}

// When sets expectation for the IRepository.OrderSuccess which will trigger the result defined by the following
// Then helper
func (mmOrderSuccess *mIRepositoryMockOrderSuccess) When(order model.Order) *IRepositoryMockOrderSuccessExpectation {
	if mmOrderSuccess.mock.funcOrderSuccess != nil {
		mmOrderSuccess.mock.t.Fatalf("IRepositoryMock.OrderSuccess mock is already set by Set")
	}

	expectation := &IRepositoryMockOrderSuccessExpectation{
		mock:   mmOrderSuccess.mock,
		params: &IRepositoryMockOrderSuccessParams{order},
	}
	mmOrderSuccess.expectations = append(mmOrderSuccess.expectations, expectation)
	return expectation
}

// Then sets up IRepository.OrderSuccess return parameters for the expectation previously defined by the When method
func (e *IRepositoryMockOrderSuccessExpectation) Then(err error) *IRepositoryMock {
	e.results = &IRepositoryMockOrderSuccessResults{err}
	return e.mock
}

// OrderSuccess implements IRepository
func (mmOrderSuccess *IRepositoryMock) OrderSuccess(order model.Order) (err error) {
	mm_atomic.AddUint64(&mmOrderSuccess.beforeOrderSuccessCounter, 1)
	defer mm_atomic.AddUint64(&mmOrderSuccess.afterOrderSuccessCounter, 1)

	if mmOrderSuccess.inspectFuncOrderSuccess != nil {
		mmOrderSuccess.inspectFuncOrderSuccess(order)
	}

	mm_params := &IRepositoryMockOrderSuccessParams{order}

	// Record call args
	mmOrderSuccess.OrderSuccessMock.mutex.Lock()
	mmOrderSuccess.OrderSuccessMock.callArgs = append(mmOrderSuccess.OrderSuccessMock.callArgs, mm_params)
	mmOrderSuccess.OrderSuccessMock.mutex.Unlock()

	for _, e := range mmOrderSuccess.OrderSuccessMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmOrderSuccess.OrderSuccessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrderSuccess.OrderSuccessMock.defaultExpectation.Counter, 1)
		mm_want := mmOrderSuccess.OrderSuccessMock.defaultExpectation.params
		mm_got := IRepositoryMockOrderSuccessParams{order}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrderSuccess.t.Errorf("IRepositoryMock.OrderSuccess got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrderSuccess.OrderSuccessMock.defaultExpectation.results
		if mm_results == nil {
			mmOrderSuccess.t.Fatal("No results are set for the IRepositoryMock.OrderSuccess")
		}
		return (*mm_results).err
	}
	if mmOrderSuccess.funcOrderSuccess != nil {
		return mmOrderSuccess.funcOrderSuccess(order)
	}
	mmOrderSuccess.t.Fatalf("Unexpected call to IRepositoryMock.OrderSuccess. %v", order)
	return
}

// OrderSuccessAfterCounter returns a count of finished IRepositoryMock.OrderSuccess invocations
func (mmOrderSuccess *IRepositoryMock) OrderSuccessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderSuccess.afterOrderSuccessCounter)
}

// OrderSuccessBeforeCounter returns a count of IRepositoryMock.OrderSuccess invocations
func (mmOrderSuccess *IRepositoryMock) OrderSuccessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderSuccess.beforeOrderSuccessCounter)
}

// Calls returns a list of arguments used in each call to IRepositoryMock.OrderSuccess.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrderSuccess *mIRepositoryMockOrderSuccess) Calls() []*IRepositoryMockOrderSuccessParams {
	mmOrderSuccess.mutex.RLock()

	argCopy := make([]*IRepositoryMockOrderSuccessParams, len(mmOrderSuccess.callArgs))
	copy(argCopy, mmOrderSuccess.callArgs)

	mmOrderSuccess.mutex.RUnlock()

	return argCopy
}

// MinimockOrderSuccessDone returns true if the count of the OrderSuccess invocations corresponds
// the number of defined expectations
func (m *IRepositoryMock) MinimockOrderSuccessDone() bool {
	for _, e := range m.OrderSuccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OrderSuccessMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOrderSuccessCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderSuccess != nil && mm_atomic.LoadUint64(&m.afterOrderSuccessCounter) < 1 {
		return false
	}
	return true
}

// MinimockOrderSuccessInspect logs each unmet expectation
func (m *IRepositoryMock) MinimockOrderSuccessInspect() {
	for _, e := range m.OrderSuccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IRepositoryMock.OrderSuccess with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OrderSuccessMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOrderSuccessCounter) < 1 {
		if m.OrderSuccessMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IRepositoryMock.OrderSuccess")
		} else {
			m.t.Errorf("Expected call to IRepositoryMock.OrderSuccess with params: %#v", *m.OrderSuccessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderSuccess != nil && mm_atomic.LoadUint64(&m.afterOrderSuccessCounter) < 1 {
		m.t.Error("Expected call to IRepositoryMock.OrderSuccess")
	}
}

type mIRepositoryMockReport struct {
	mock               *IRepositoryMock
	defaultExpectation *IRepositoryMockReportExpectation
	expectations       []*IRepositoryMockReportExpectation

	callArgs []*IRepositoryMockReportParams
	mutex    sync.RWMutex
}

// IRepositoryMockReportExpectation specifies expectation struct of the IRepository.Report
type IRepositoryMockReportExpectation struct {
	mock    *IRepositoryMock
	params  *IRepositoryMockReportParams
	results *IRepositoryMockReportResults
	Counter uint64
}

// IRepositoryMockReportParams contains parameters of the IRepository.Report
type IRepositoryMockReportParams struct {
	t1 time.Time
}

// IRepositoryMockReportResults contains results of the IRepository.Report
type IRepositoryMockReportResults struct {
	ra1 []model.Report
	err error
}

// Expect sets up expected params for IRepository.Report
func (mmReport *mIRepositoryMockReport) Expect(t1 time.Time) *mIRepositoryMockReport {
	if mmReport.mock.funcReport != nil {
		mmReport.mock.t.Fatalf("IRepositoryMock.Report mock is already set by Set")
	}

	if mmReport.defaultExpectation == nil {
		mmReport.defaultExpectation = &IRepositoryMockReportExpectation{}
	}

	mmReport.defaultExpectation.params = &IRepositoryMockReportParams{t1}
	for _, e := range mmReport.expectations {
		if minimock.Equal(e.params, mmReport.defaultExpectation.params) {
			mmReport.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReport.defaultExpectation.params)
		}
	}

	return mmReport
}

// Inspect accepts an inspector function that has same arguments as the IRepository.Report
func (mmReport *mIRepositoryMockReport) Inspect(f func(t1 time.Time)) *mIRepositoryMockReport {
	if mmReport.mock.inspectFuncReport != nil {
		mmReport.mock.t.Fatalf("Inspect function is already set for IRepositoryMock.Report")
	}

	mmReport.mock.inspectFuncReport = f

	return mmReport
}

// Return sets up results that will be returned by IRepository.Report
func (mmReport *mIRepositoryMockReport) Return(ra1 []model.Report, err error) *IRepositoryMock {
	if mmReport.mock.funcReport != nil {
		mmReport.mock.t.Fatalf("IRepositoryMock.Report mock is already set by Set")
	}

	if mmReport.defaultExpectation == nil {
		mmReport.defaultExpectation = &IRepositoryMockReportExpectation{mock: mmReport.mock}
	}
	mmReport.defaultExpectation.results = &IRepositoryMockReportResults{ra1, err}
	return mmReport.mock
}

//Set uses given function f to mock the IRepository.Report method
func (mmReport *mIRepositoryMockReport) Set(f func(t1 time.Time) (ra1 []model.Report, err error)) *IRepositoryMock {
	if mmReport.defaultExpectation != nil {
		mmReport.mock.t.Fatalf("Default expectation is already set for the IRepository.Report method")
	}

	if len(mmReport.expectations) > 0 {
		mmReport.mock.t.Fatalf("Some expectations are already set for the IRepository.Report method")
	}

	mmReport.mock.funcReport = f
	return mmReport.mock
}

// When sets expectation for the IRepository.Report which will trigger the result defined by the following
// Then helper
func (mmReport *mIRepositoryMockReport) When(t1 time.Time) *IRepositoryMockReportExpectation {
	if mmReport.mock.funcReport != nil {
		mmReport.mock.t.Fatalf("IRepositoryMock.Report mock is already set by Set")
	}

	expectation := &IRepositoryMockReportExpectation{
		mock:   mmReport.mock,
		params: &IRepositoryMockReportParams{t1},
	}
	mmReport.expectations = append(mmReport.expectations, expectation)
	return expectation
}

// Then sets up IRepository.Report return parameters for the expectation previously defined by the When method
func (e *IRepositoryMockReportExpectation) Then(ra1 []model.Report, err error) *IRepositoryMock {
	e.results = &IRepositoryMockReportResults{ra1, err}
	return e.mock
}

// Report implements IRepository
func (mmReport *IRepositoryMock) Report(t1 time.Time) (ra1 []model.Report, err error) {
	mm_atomic.AddUint64(&mmReport.beforeReportCounter, 1)
	defer mm_atomic.AddUint64(&mmReport.afterReportCounter, 1)

	if mmReport.inspectFuncReport != nil {
		mmReport.inspectFuncReport(t1)
	}

	mm_params := &IRepositoryMockReportParams{t1}

	// Record call args
	mmReport.ReportMock.mutex.Lock()
	mmReport.ReportMock.callArgs = append(mmReport.ReportMock.callArgs, mm_params)
	mmReport.ReportMock.mutex.Unlock()

	for _, e := range mmReport.ReportMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ra1, e.results.err
		}
	}

	if mmReport.ReportMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReport.ReportMock.defaultExpectation.Counter, 1)
		mm_want := mmReport.ReportMock.defaultExpectation.params
		mm_got := IRepositoryMockReportParams{t1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReport.t.Errorf("IRepositoryMock.Report got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReport.ReportMock.defaultExpectation.results
		if mm_results == nil {
			mmReport.t.Fatal("No results are set for the IRepositoryMock.Report")
		}
		return (*mm_results).ra1, (*mm_results).err
	}
	if mmReport.funcReport != nil {
		return mmReport.funcReport(t1)
	}
	mmReport.t.Fatalf("Unexpected call to IRepositoryMock.Report. %v", t1)
	return
}

// ReportAfterCounter returns a count of finished IRepositoryMock.Report invocations
func (mmReport *IRepositoryMock) ReportAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReport.afterReportCounter)
}

// ReportBeforeCounter returns a count of IRepositoryMock.Report invocations
func (mmReport *IRepositoryMock) ReportBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReport.beforeReportCounter)
}

// Calls returns a list of arguments used in each call to IRepositoryMock.Report.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReport *mIRepositoryMockReport) Calls() []*IRepositoryMockReportParams {
	mmReport.mutex.RLock()

	argCopy := make([]*IRepositoryMockReportParams, len(mmReport.callArgs))
	copy(argCopy, mmReport.callArgs)

	mmReport.mutex.RUnlock()

	return argCopy
}

// MinimockReportDone returns true if the count of the Report invocations corresponds
// the number of defined expectations
func (m *IRepositoryMock) MinimockReportDone() bool {
	for _, e := range m.ReportMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReportMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReportCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReport != nil && mm_atomic.LoadUint64(&m.afterReportCounter) < 1 {
		return false
	}
	return true
}

// MinimockReportInspect logs each unmet expectation
func (m *IRepositoryMock) MinimockReportInspect() {
	for _, e := range m.ReportMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IRepositoryMock.Report with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReportMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReportCounter) < 1 {
		if m.ReportMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IRepositoryMock.Report")
		} else {
			m.t.Errorf("Expected call to IRepositoryMock.Report with params: %#v", *m.ReportMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReport != nil && mm_atomic.LoadUint64(&m.afterReportCounter) < 1 {
		m.t.Error("Expected call to IRepositoryMock.Report")
	}
}

type mIRepositoryMockTransfer struct {
	mock               *IRepositoryMock
	defaultExpectation *IRepositoryMockTransferExpectation
	expectations       []*IRepositoryMockTransferExpectation

	callArgs []*IRepositoryMockTransferParams
	mutex    sync.RWMutex
}

// IRepositoryMockTransferExpectation specifies expectation struct of the IRepository.Transfer
type IRepositoryMockTransferExpectation struct {
	mock    *IRepositoryMock
	params  *IRepositoryMockTransferParams
	results *IRepositoryMockTransferResults
	Counter uint64
}

// IRepositoryMockTransferParams contains parameters of the IRepository.Transfer
type IRepositoryMockTransferParams struct {
	sender    model.User
	recipient model.User
	funds     float64
}

// IRepositoryMockTransferResults contains results of the IRepository.Transfer
type IRepositoryMockTransferResults struct {
	err error
}

// Expect sets up expected params for IRepository.Transfer
func (mmTransfer *mIRepositoryMockTransfer) Expect(sender model.User, recipient model.User, funds float64) *mIRepositoryMockTransfer {
	if mmTransfer.mock.funcTransfer != nil {
		mmTransfer.mock.t.Fatalf("IRepositoryMock.Transfer mock is already set by Set")
	}

	if mmTransfer.defaultExpectation == nil {
		mmTransfer.defaultExpectation = &IRepositoryMockTransferExpectation{}
	}

	mmTransfer.defaultExpectation.params = &IRepositoryMockTransferParams{sender, recipient, funds}
	for _, e := range mmTransfer.expectations {
		if minimock.Equal(e.params, mmTransfer.defaultExpectation.params) {
			mmTransfer.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTransfer.defaultExpectation.params)
		}
	}

	return mmTransfer
}

// Inspect accepts an inspector function that has same arguments as the IRepository.Transfer
func (mmTransfer *mIRepositoryMockTransfer) Inspect(f func(sender model.User, recipient model.User, funds float64)) *mIRepositoryMockTransfer {
	if mmTransfer.mock.inspectFuncTransfer != nil {
		mmTransfer.mock.t.Fatalf("Inspect function is already set for IRepositoryMock.Transfer")
	}

	mmTransfer.mock.inspectFuncTransfer = f

	return mmTransfer
}

// Return sets up results that will be returned by IRepository.Transfer
func (mmTransfer *mIRepositoryMockTransfer) Return(err error) *IRepositoryMock {
	if mmTransfer.mock.funcTransfer != nil {
		mmTransfer.mock.t.Fatalf("IRepositoryMock.Transfer mock is already set by Set")
	}

	if mmTransfer.defaultExpectation == nil {
		mmTransfer.defaultExpectation = &IRepositoryMockTransferExpectation{mock: mmTransfer.mock}
	}
	mmTransfer.defaultExpectation.results = &IRepositoryMockTransferResults{err}
	return mmTransfer.mock
}

//Set uses given function f to mock the IRepository.Transfer method
func (mmTransfer *mIRepositoryMockTransfer) Set(f func(sender model.User, recipient model.User, funds float64) (err error)) *IRepositoryMock {
	if mmTransfer.defaultExpectation != nil {
		mmTransfer.mock.t.Fatalf("Default expectation is already set for the IRepository.Transfer method")
	}

	if len(mmTransfer.expectations) > 0 {
		mmTransfer.mock.t.Fatalf("Some expectations are already set for the IRepository.Transfer method")
	}

	mmTransfer.mock.funcTransfer = f
	return mmTransfer.mock
}

// When sets expectation for the IRepository.Transfer which will trigger the result defined by the following
// Then helper
func (mmTransfer *mIRepositoryMockTransfer) When(sender model.User, recipient model.User, funds float64) *IRepositoryMockTransferExpectation {
	if mmTransfer.mock.funcTransfer != nil {
		mmTransfer.mock.t.Fatalf("IRepositoryMock.Transfer mock is already set by Set")
	}

	expectation := &IRepositoryMockTransferExpectation{
		mock:   mmTransfer.mock,
		params: &IRepositoryMockTransferParams{sender, recipient, funds},
	}
	mmTransfer.expectations = append(mmTransfer.expectations, expectation)
	return expectation
}

// Then sets up IRepository.Transfer return parameters for the expectation previously defined by the When method
func (e *IRepositoryMockTransferExpectation) Then(err error) *IRepositoryMock {
	e.results = &IRepositoryMockTransferResults{err}
	return e.mock
}

// Transfer implements IRepository
func (mmTransfer *IRepositoryMock) Transfer(sender model.User, recipient model.User, funds float64) (err error) {
	mm_atomic.AddUint64(&mmTransfer.beforeTransferCounter, 1)
	defer mm_atomic.AddUint64(&mmTransfer.afterTransferCounter, 1)

	if mmTransfer.inspectFuncTransfer != nil {
		mmTransfer.inspectFuncTransfer(sender, recipient, funds)
	}

	mm_params := &IRepositoryMockTransferParams{sender, recipient, funds}

	// Record call args
	mmTransfer.TransferMock.mutex.Lock()
	mmTransfer.TransferMock.callArgs = append(mmTransfer.TransferMock.callArgs, mm_params)
	mmTransfer.TransferMock.mutex.Unlock()

	for _, e := range mmTransfer.TransferMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmTransfer.TransferMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTransfer.TransferMock.defaultExpectation.Counter, 1)
		mm_want := mmTransfer.TransferMock.defaultExpectation.params
		mm_got := IRepositoryMockTransferParams{sender, recipient, funds}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTransfer.t.Errorf("IRepositoryMock.Transfer got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTransfer.TransferMock.defaultExpectation.results
		if mm_results == nil {
			mmTransfer.t.Fatal("No results are set for the IRepositoryMock.Transfer")
		}
		return (*mm_results).err
	}
	if mmTransfer.funcTransfer != nil {
		return mmTransfer.funcTransfer(sender, recipient, funds)
	}
	mmTransfer.t.Fatalf("Unexpected call to IRepositoryMock.Transfer. %v %v %v", sender, recipient, funds)
	return
}

// TransferAfterCounter returns a count of finished IRepositoryMock.Transfer invocations
func (mmTransfer *IRepositoryMock) TransferAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTransfer.afterTransferCounter)
}

// TransferBeforeCounter returns a count of IRepositoryMock.Transfer invocations
func (mmTransfer *IRepositoryMock) TransferBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTransfer.beforeTransferCounter)
}

// Calls returns a list of arguments used in each call to IRepositoryMock.Transfer.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTransfer *mIRepositoryMockTransfer) Calls() []*IRepositoryMockTransferParams {
	mmTransfer.mutex.RLock()

	argCopy := make([]*IRepositoryMockTransferParams, len(mmTransfer.callArgs))
	copy(argCopy, mmTransfer.callArgs)

	mmTransfer.mutex.RUnlock()

	return argCopy
}

// MinimockTransferDone returns true if the count of the Transfer invocations corresponds
// the number of defined expectations
func (m *IRepositoryMock) MinimockTransferDone() bool {
	for _, e := range m.TransferMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TransferMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTransferCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTransfer != nil && mm_atomic.LoadUint64(&m.afterTransferCounter) < 1 {
		return false
	}
	return true
}

// MinimockTransferInspect logs each unmet expectation
func (m *IRepositoryMock) MinimockTransferInspect() {
	for _, e := range m.TransferMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IRepositoryMock.Transfer with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TransferMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTransferCounter) < 1 {
		if m.TransferMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IRepositoryMock.Transfer")
		} else {
			m.t.Errorf("Expected call to IRepositoryMock.Transfer with params: %#v", *m.TransferMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTransfer != nil && mm_atomic.LoadUint64(&m.afterTransferCounter) < 1 {
		m.t.Error("Expected call to IRepositoryMock.Transfer")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddUserInspect()

		m.MinimockBalanceInspect()

		m.MinimockEnrollmentInspect()

		m.MinimockGetOrderInspect()

		m.MinimockHistoryInspect()

		m.MinimockOrderInspect()

		m.MinimockOrderFailedInspect()

		m.MinimockOrderSuccessInspect()

		m.MinimockReportInspect()

		m.MinimockTransferInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddUserDone() &&
		m.MinimockBalanceDone() &&
		m.MinimockEnrollmentDone() &&
		m.MinimockGetOrderDone() &&
		m.MinimockHistoryDone() &&
		m.MinimockOrderDone() &&
		m.MinimockOrderFailedDone() &&
		m.MinimockOrderSuccessDone() &&
		m.MinimockReportDone() &&
		m.MinimockTransferDone()
}
